

/*********************************************************************/
/************************** Node ***************************************/
/*********************************************************************/

// node copy constructor
template <typename N, typename E>
Node<N, E>::Node(const Node &cpy)  {
    value_ = cpy.value_;
    std::shared_ptr<Edge<N, E>> itorator;
    std::shared_ptr<Edge<N, E>> itorator_new;
    itorator = cpy.next_;
    if(itorator != nullptr) {
        next_ = std::make_shared<Edge<N, E>>(itorator->getw(), itorator->geti());
        itorator_new = next_;
        itorator = itorator->getn();
    } else {
        return ;
    }
    while(itorator!= nullptr) {
        // generate new edge node
        itorator_new->setn(std::make_shared<Edge<N, E>>(itorator->getw(), itorator->geti()));
        // go through old
        itorator = itorator->getn();
        // go through new
        itorator_new = itorator_new->getn();
    }
};

// MEMBER FUNCTION
// set new next
template <typename N, typename E>
void Node<N, E>::setn(std::shared_ptr<Edge<N, E>> new_edge) {
    if (next_ == nullptr) {
        next_ = new_edge;
    } else {
        std::shared_ptr<Edge<N, E>> itorator = next_;
        while (itorator->getn() != nullptr) {
            itorator = itorator->getn();
        }
        itorator->setn(new_edge);
    }
};

// get value_
template <typename N, typename E>
N Node<N, E>::getv() {
    return value_;
};
// get next_
template <typename N, typename E>
std::shared_ptr<Edge<N, E>> Node<N, E>::getn() {
    return next_;
};
// print value of node and its out edge;
template <typename N, typename E>
void Node<N, E>::printnode() {
    std::shared_ptr<Edge<N, E>> itorator;
    if(next_ != nullptr) {
        itorator = next_;
    }
    else {
        std::cout<<"(null)\n";
        return;
    }
    while (itorator != nullptr) {
        std::cout<<itorator->getnvalue()<<"\n";
        std::cout<<itorator->getw()<<"\n";
        itorator = itorator->getn();
    }
};

/*********************************************************************/
/************************** Edge ***************************************/
/*********************************************************************/
// get weight
template <typename N, typename E>
E Edge<N, E>::getw() {
    return weight_;
}
// get nvalue
template <typename N, typename E>
N Edge<N, E>::getnvalue() {
    return nvalue_;
}
// get next edge pointer
template <typename N, typename E>
std::shared_ptr<Edge<N, E>> Edge<N, E>::getn() {
    return next_;
}
// set next edge pointer
template <typename N, typename E>
void Edge<N, E>::setn(std::shared_ptr<Edge<N, E>> n) {
    next_ = n;
}



/*************************************************************************/
/************************** Graph ***************************************/
/***********************************************************************/


// graph deep copy constructor;
template <typename N, typename E>
Graph<N, E>::Graph(const Graph<N, E> &cpy) {
    for(unsigned int i = 0; i < cpy.node_.size(); i++) {
        Node<N, E> new_node(*cpy.node_[i]);
        node_.pop_back(std::make_shared<Node<N, E>>(new_node));
    }
}

// move constructor
template <typename N, typename E>
Graph<N, E>::Graph(Graph<N, E> &&cpy) {
    for(unsigned int i = 0; i < cpy.node_.size(); i++) {
        node_.pop_back(cpy.node_[i]);
        cpy.node_[i] = nullptr;
    }
}

// return numer of node
template <typename N, typename E>
int Graph<N, E>::num_node() {
    return node_.size();
}

// add new node
template <typename N, typename E>
bool Graph<N, E>::addNode(const N &val) {
    for (unsigned int i = 0; i < num_node(); ++i) {
        if(node_[i]->getv() == val)
        {
            return false;
        }
    }
    std::shared_ptr<Node<N, E>> insert = std::make_shared<Node<N, E>>(val);
    node_.push_back(insert);
    sort();
    return true;
}

// add new edge
template <typename N, typename E>
bool Graph<N, E>::addEdge(const N &src, const N &dst, const E &w) {
    // record index
    int srci = -1;
    int dsti = -1;
    try {
        for (unsigned i = 0; i < num_node(); ++i) {
            if (node_[i]->getv() == src) {
                srci = i;
            }
            if (node_[i]->getv() == dst) {
                dsti = i;
            }
        }
        if (srci == -1 || dsti == -1) {
            throw std::runtime_error("can't find node");
        }
    }
    catch (std::runtime_error &e) {
        std::cout<<"oh no";
    }
    auto itorator = node_[srci]->getn();
    while (itorator != nullptr) {
        if((*itorator).getw() == w && (*itorator).getnvalue() == dsti) {
            return false;
        }
        if (itorator->getn()!= nullptr) {
            itorator = itorator->getn();
        } else {
            break;
        }
    }
    auto new_edge = std::make_shared<Edge<N, E>>(dst, w);
    if(itorator == nullptr) {
        node_[srci]->setn(new_edge);
    } else {
        itorator->setn(new_edge);
    }
    sort();
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename N, typename E>
unsigned int Node<N, E>::size() {
    auto itroator = next_;
    unsigned int i = 0;
    while (itroator != nullptr) {
        ++i;
        itroator = itroator->getn();
    }
    return i;
}
// sort graph
template <typename N, typename E>
void Graph<N, E>::sort() {
    unsigned int i,j;
    for (i = 0;i<=num_node()-1;++i){
        for (j = 0; j < num_node() - 1 - i; ++j) {
            if(node_[j]->size() > node_[j + 1]->size()) {
                auto tmp = node_[j];
                node_[j] = node_[j+1];
                node_[j+1] = tmp;
            }
            if(node_[j]->size() == node_[j + 1]->size()) {
                if (node_[j]->getv() > node_[j+1]->getv()) {
                    auto tmp = node_[j];
                    node_[j] = node_[j+1];
                    node_[j+1] = tmp;
                }
            }
        }
    }
}

// print nodes
template <typename N, typename E>
void Graph<N, E>::printNodes() const{
    for (unsigned int i = 0; i < node_.size(); ++i) {
        std::cout<<node_[i]->getv()<<"\n";

    }
}
// check if this is a node
template <typename N, typename E>
bool Graph<N, E>::isNode(const N &val) const {
    for (unsigned int i = 0; i < num_node(); ++i) {
        if(node_[i]->getv == val) {
            return true;
        }
    }
    return false;
}
// check if Connected
template <typename N, typename E>
bool Graph<N, E>::isConnected(const N &src, const N &dst) const {
    for (unsigned int i = 0; i < num_node(); ++i) {
        if(node_[i]->getv == src) {
            auto itorator = node_[i]->getn();
            while (itorator != nullptr) {
                if (itorator->getnvalue() == dst) {
                    return true;
                }
                itorator = itorator->getn();
            }
        }
    }
    return false;
}
// clear vector
template <typename N, typename E>
void Graph<N, E>::clear() noexcept {
    node_.clear();
}
// Graph delete Edge
template <typename N, typename E>
void Graph<N, E>::deleteEdge(const N &src, const N &dst, const E &w) noexcept {
    for (unsigned int i = 0; i < num_node(); ++i) {
        if(node_[i]->getv == src) {
            node_[i]->removeedge(dst, w);
            sort();
            return;
        }
    }
}


// Graph delete node
template <typename N, typename E>
void Graph<N, E>::deleteNode(const N &dnode) noexcept {
    // remove outgoing edge
    for (unsigned int i = 0; i < num_node(); ++i) {
        if(node_[i]->getv == dnode) {
            node_.erase(node_.begin() + i);
            break;
        }
    }
    // remove incoming edge
    for (unsigned int i = 0; i < num_node(); ++i) {
        int flag = 1;
        while (flag == 1) {
            if (node_[i]->removeedge(dnode) == 0) {
                flag = 0;
            }
        }
    }
}

// remove edge base value
template <typename N, typename E>
void Node<N, E>::removeedge(const N &node, const E &weight) {
    auto itorator = next_;
    auto pre = next_;
    if (itorator == nullptr) {
        return;
    }
    if (itorator->getn() == nullptr) {
        if(itorator->getnvlue() = node && itorator->getw() = weight) {
            delete itorator;
            itorator = nullptr;
            next_ = nullptr;
        }
        return;
    }
    itorator = itorator->getn();
    while (itorator->getn() != nullptr) {
        if(itorator->getnvlue() = node && itorator->getw() = weight) {
            pre->setn(itorator);
            delete itorator;
            itorator = nullptr;
            return;
        }
        pre = itorator;
        itorator = itorator->getn();
    }
    if(itorator->getnvlue() = node && itorator->getw() = weight) {
        pre->setn(itorator);
        delete itorator;
        itorator = nullptr;
    }
    return;
}
// remove edge
template <typename N, typename E>
bool Node<N, E>::removeedge(const N &node) {
    auto itorator = next_;
    auto pre = next_;
    if (itorator == nullptr) {
        return false;
    }
    if (itorator->getn() == nullptr) {
        if(itorator->getnvlue() = node ) {
            delete itorator;
            itorator = nullptr;
            next_ = nullptr;
            return true;
        }
        return false;
    }
    itorator = itorator->getn();
    while (itorator->getn() != nullptr) {
        if(itorator->getnvlue() = node ) {
            pre->setn(itorator);
            delete itorator;
            itorator = nullptr;
            return true;
        }
        pre = itorator;
        itorator = itorator->getn();
    }
    if(itorator->getnvlue() = node) {
        pre->setn(itorator);
        delete itorator;
        itorator = nullptr;
        return true;
    }
    return false;
}
//  merge same
template <typename N, typename E>
void Node<N, E>::merge(const N &old_edge, const N & new_edge) {
    auto itorator = next_;
    std::vector<E> memory;
    while (itorator != nullptr) {
        if(itorator->getnvlue() == old_edge || itorator->getnvlue() == new_edge) {
            itorator->setnvalue(new_edge);
            int flag = 0;
            for (unsigned int i = 0; i < memory.size(); ++i) {
                if (memory[i] == itorator->getw()) {
                    flag = 1;
                    break;
                }
            }
            if (flag == 1) {
                auto tmp = itorator;
                itorator = itorator->getn();
                removeedge(tmp->getnvlue(), tmp->getw());
            }
            else {
                memory.push_back(itorator->getw());
                itorator = itorator->getn();
            }
        }
    }
}
// set nvalue
template <typename N, typename E>
void Edge<N, E>::setnvalue(N nvalue) {
    nvalue_ = nvalue;

}

// node add new edge
template <typename N, typename E>
void Node<N, E>::addnewedge(const Edge<N, E> &edge) {
    auto itorator = next_;
    while (itorator != nullptr) {
        if (itorator->getn() != nullptr) {
            itorator = itorator->getn();
        } else {
            break;
        }
    }
    itorator->setn(std::make_shared<Edge<N,E>>(edge.getnvlue(), edge.getw()));

}

// friend operator
template <typename N, typename E>
bool operator == (const Edge<N, E> &lft, const Edge<N, E> &rht) {

    return lft.nvalue_==rht.nvalue_ && lft.weight_==rht.weight_;
}


// replace node value
template <typename N, typename E>
bool Graph<N, E>::replace(const N& oldData, const N& newData) {
    int oldi = -1;
    int newi = -1;
    for (unsigned int i = 0; i < num_node(); ++i) {
        if (node_[i]->getv() == oldData ) {
            oldi = i;
        }
        if (node_[i]->getv() == newData ) {
            newi = i;
        }
    }
    try {
        if(oldi == -1) {
            throw std::runtime_error("can't find src node");
        }
        if(newi != -1) {
            return false;
        }
        node_[oldi]->setn(std::make_shared<Edge<N, E>>(newData));
        sort();
        return true;
    }
    catch (std::runtime_error &e) {
        std::cout<<"can't find src node";
    }
};

// Check if node contains same edge
template <typename N, typename E>
bool Node<N, E>::containedge(const Edge<N, E> &edge) {
    auto itorator = next_;
    while (itorator != nullptr) {
        if (*itorator == edge) {
            return true;
        }
        itorator = itorator->getn();
    }
    return false;
}



// replace and merge node value
template <typename N, typename E>
void Graph<N, E>::mergeReplace(const N &oldData, const N &newData) {
    int oldi = -1;
    int newi = -1;
    for (unsigned int i = 0; i < num_node(); ++i) {
        if (node_[i]->getv() == oldData) {
            oldi = i;
        }
        if (node_[i]->getv() == newData) {
            newi = i;
        }
    }
    try {
        if(oldi == -1 || newi == -1) {
            throw std::runtime_error("can't find one of the node");
        }
        auto itorator = node_[oldi]->getn();
        // merge all the outgoing edge
        while (itorator != nullptr) {
            if(!node_[newi]->containedge(*itorator)) {
                node_[newi]->addnewedge(*itorator);
            }
            itorator = itorator->getn();
        }
        // merge all the incoming edge
        for (unsigned int i = 0; i < num_node() ; ++i) {
            if(i == oldi || i = newi) {
                continue;
            }
            node_[newi]->merge(oldData, newData);
        }
        // delete old node
        node_.erase(node_.begin() + oldi);
        sort();
    }
    catch (std::runtime_error &e) {
        std::cout<<"can't find one of the node";
    }

};






























